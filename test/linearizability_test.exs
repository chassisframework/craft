defmodule Craft.LinearizabilityTest do
  use Craft.NexusCase

  alias Craft.Nexus.Stability
  alias Craft.Linearizability.Operation

  @moduletag timeout: :timer.minutes(20)

  nexus_test "under ideal conditions", %{nodes: nodes, name: name, nexus: nexus} do
    wait_until(nexus, {Stability, :all})
    num_clients = 20

    history =
      1..num_clients
      |> Task.async_stream(fn _ -> do_random_commands(name, nodes, 100) end, timeout: :infinity)
      |> Enum.flat_map(fn {:ok, ops} -> ops end)

    IO.puts "checking a total of #{length(history)} operations generated by #{num_clients} parallel clients"
    :timer.tc(fn ->
      assert {:ok, linearized_history, _ignored_ops = []} = Craft.Linearizability.linearize(history, Craft.SimpleMachine)
      File.write!("history", :erlang.term_to_binary({linearized_history, []}))
      Craft.Linearizability.Visualization.to_file(nil)
    end, :second)
  end

  nexus_test "during leadership transfer", %{nodes: nodes, name: name, nexus: nexus} do
    %{leader: leader} = wait_until(nexus, {Stability, :all})

    num_clients = 20

    tasks = Enum.map(1..num_clients, fn _ ->
      Task.async(fn -> do_random_commands(name, nodes, 10) end)
    end)

    # new_leader = Enum.random(nodes -- [leader])
    # Craft.transfer_leadership(name, new_leader, nodes)

    history =
      tasks
      |> Task.await_many(:infinity)
      |> List.flatten()

    # assert %{leader: ^new_leader} = wait_until(nexus, {Stability, :all})

    IO.puts "checking a total of #{length(history)} operations generated by #{num_clients} parallel clients"
    :timer.tc(fn ->
      assert {:ok, linearized_history, ignored_ops} = Craft.Linearizability.linearize(history, Craft.SimpleMachine)
      File.write!("history", :erlang.term_to_binary({linearized_history, ignored_ops}))
      Craft.Linearizability.Visualization.to_file(nil)
    end, :second)
  end

  defp do_random_commands(name, nodes, num) do
    for i <- 1..num do
      value =
        self()
        |> :erlang.pid_to_list()
        |> :erlang.list_to_binary()
        |> String.trim("<")
        |> String.trim(">")

      command =
        Enum.random([
          {:put, :a, "#{value}_#{i}"},
          {:get, :a}
        ])

      Process.sleep(:rand.uniform(100))
      do_command(name, nodes, command)
    end
  end

  defp do_command(name, nodes, command) do
    called_at = :erlang.monotonic_time()
    response = Craft.command(command, name, nodes)
    received_at = :erlang.monotonic_time()

    %Operation{
      id: {self(), called_at},
      client: self(),
      called_at: called_at,
      received_at: received_at,
      command: command,
      response: response
    }
  end
end
